(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "../core/constants", "../core/Context", "@smartface/styler/lib/utils/merge"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("../core/constants"), require("../core/Context"), require("@smartface/styler/lib/utils/merge"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.constants, global.Context, global.merge);
    global.StyleContext = mod.exports;
  }
})(this, function (exports, _constants, _Context, _merge) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createStyleContext = createStyleContext;

  var _Context2 = _interopRequireDefault(_Context);

  var _merge2 = _interopRequireDefault(_merge);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  /**
   * Style Context. Returns context composer
   * 
   * @param {Array.<Object>} actors - Actors List
   * @param {function} hookMaybe - Hooks factory
   * @returns {function} - Context Composer Function
   */
  function createStyleContext(actors, hookMaybe, updateContextTree) {
    var context;

    /**
     * Context builder.
     * 
     * @param {function) styling - Styling function from styler.
     * @param {function} reducer - Reducer function to run actions
     */
    return function recomposeStylingContext(styling, reducer) {

      // context reducer
      function contextUpdater(context, action, target) {
        var state = context.getState();
        var newState = state;

        if (target || action.type == _constants.INIT_CONTEXT_ACTION_TYPE) {
          newState = reducer(context, action, target);
        }

        switch (action.type) {
          case 'updateContext':
            updateContextTree(context.actors);

            break;
          case 'forceComponentUpdate':
            var actor = context.find(target + "_" + action.name, null);
            actor && actor.reset();

            break;
          /*case 'addContextChild':
            Array.isArray(action.newComp)
              ? action.newComp.forEach((component) => {
                  context.add(component);
                })
              : context.add(action.newComp);
          break;*/
          case 'removeContextChild':
            context.remove(action.name);
            break;
        }

        if (target && action.type !== _constants.INIT_CONTEXT_ACTION_TYPE) {
          // state is not changed
          if (newState === state) {
            // return current state instance
            return state;
          }
        }

        context.map(function invalidateStyles(actor, name) {
          if (actor.isDirty === true || action.type === _constants.INIT_CONTEXT_ACTION_TYPE) {
            var className = actor.getClassName();
            var beforeHook = hookMaybe("beforeAssignComponentStyles", null);
            beforeHook && (className = beforeHook(name, className));

            try {
              if (className) {
                var styles = styling(className)();
                actor.setStyles(styles);
              }

              actor.applyStyles();
            } catch (e) {
              e.message = "While actor's style [" + name + "] is set. " + e.message;

              throw e;
            }
          }
        });

        latestState = newState;

        return newState;
      }

      var latestState = context ? context.getState() : {};
      //creates new context
      context = new _Context2.default(context && context.reduce(function (acc, actor, name) {
        acc[name] = actor;return acc;
      }, {}) || actors, contextUpdater, latestState, hookMaybe);

      return context;
    };
  }
});