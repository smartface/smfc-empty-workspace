(function (global, factory) {
	if (typeof define === "function" && define.amd) {
		define(["module", "exports", "../styling/StyleContext", "@smartface/styler/lib/styler", "@smartface/styler/lib/commandsManager", "@smartface/styler/lib/utils/merge", "./sfCorePropFactory", "sf-core/device/screen", "sf-core/device/system", "../core/isTablet", "../styling/Stylable", "../core/hooks", "../core/constants", "./fromSFComponent"], factory);
	} else if (typeof exports !== "undefined") {
		factory(module, exports, require("../styling/StyleContext"), require("@smartface/styler/lib/styler"), require("@smartface/styler/lib/commandsManager"), require("@smartface/styler/lib/utils/merge"), require("./sfCorePropFactory"), require("sf-core/device/screen"), require("sf-core/device/system"), require("../core/isTablet"), require("../styling/Stylable"), require("../core/hooks"), require("../core/constants"), require("./fromSFComponent"));
	} else {
		var mod = {
			exports: {}
		};
		factory(mod, mod.exports, global.StyleContext, global.styler, global.commandsManager, global.merge, global.sfCorePropFactory, global.screen, global.system, global.isTablet, global.Stylable, global.hooks, global.constants, global.fromSFComponent);
		global.pageContext = mod.exports;
	}
})(this, function (module, exports, _StyleContext, _styler, _commandsManager, _merge, _sfCorePropFactory, _screen, _system, _isTablet, _Stylable, _hooks, _constants, _fromSFComponent) {
	"use strict";

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var StyleContext = _interopRequireWildcard(_StyleContext);

	var _styler2 = _interopRequireDefault(_styler);

	var _commandsManager2 = _interopRequireDefault(_commandsManager);

	var _merge2 = _interopRequireDefault(_merge);

	var _sfCorePropFactory2 = _interopRequireDefault(_sfCorePropFactory);

	var _screen2 = _interopRequireDefault(_screen);

	var _system2 = _interopRequireDefault(_system);

	var _isTablet2 = _interopRequireDefault(_isTablet);

	var _Stylable2 = _interopRequireDefault(_Stylable);

	var _hooks2 = _interopRequireDefault(_hooks);

	var _constants2 = _interopRequireDefault(_constants);

	var _fromSFComponent2 = _interopRequireDefault(_fromSFComponent);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : {
			default: obj
		};
	}

	function _interopRequireWildcard(obj) {
		if (obj && obj.__esModule) {
			return obj;
		} else {
			var newObj = {};

			if (obj != null) {
				for (var key in obj) {
					if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
				}
			}

			newObj.default = obj;
			return newObj;
		}
	}

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
		return typeof obj;
	} : function (obj) {
		return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	};

	// import Filtrex from 'filtrex'

	var orientationState = "ended";

	_commandsManager2.default.addRuntimeCommandFactory(function pageContextRuntimeCommandFactory(type, error) {
		switch (type) {
			case '+Device':
				return function deviceRule(opts) {
					var Device = {
						screen: {
							width: _screen2.default.width,
							height: _screen2.default.height
						},
						os: _system2.default.OS,
						osVersion: _system2.default.OSVersion,
						type: _isTablet2.default ? "tablet" : "phone",
						orientation: _screen2.default.width > _screen2.default.height ? "landscape" : "portrait",
						language: _system2.default.language
					};

					opts = (0, _merge2.default)(opts);
					try {
						var isOK = eval(opts.args);
					} catch (e) {
						error && error(e);
						return {};
					}

					return isOK ? opts.value : {};
				};
		}
	});

	function createPageContext(component, name) {
		var classMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
		var reducers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

		var styleContext = (0, _fromSFComponent2.default)(component, name,
		//context hooks
		function (hook) {
			switch (hook) {
				// case 'beforeAssignComponentStyles':
				// 	return function beforeAssignComponentStyles(name, className) {
				// 		return className;
				// 	};
				case 'beforeStyleDiffAssign':
					return function beforeStyleDiffAssign(styles) {
						return (0, _sfCorePropFactory2.default)(styles);
					};
				case 'reduceDiffStyleHook':
					return function reduceDiffStyleHook(oldStyles, newStyles) {
						function isEqual(oldStyle, newStyle) {
							if (oldStyle === undefined) {
								return false;
							}

							var keys1 = Object.keys(oldStyle);
							var keys2 = Object.keys(newStyle);

							if (keys1.length !== keys2.length) {
								return false;
							}

							var res = keys2.some(function (key) {
								return oldStyle[key] !== newStyle[key];
							});

							return !res;
						}

						return function diffStylingReducer(acc, key) {
							// align is readolnly issue on Android
							if (key === 'align') {
								delete acc[key];
								return acc;
							} else if (key == "flexProps") {
								Object.keys(newStyles[key]).forEach(function (name) {
									if (oldStyles[key] === undefined || newStyles[key][name] !== oldStyles[key][name]) {
										acc[name] = newStyles[key][name];

										if (newStyles[key][name] === null) {
											acc[name] = NaN;
											// fixes flexgrow NaN value bug
											if (name === "flexGrow") {
												acc[name] = 0;
											}
										} else {
											acc[name] = newStyles[key][name];
										}
									}
								});
							} else if (newStyles[key] !== null && _typeof(newStyles[key]) === "object") {
								if (Object.keys(newStyles[key]).length > 0 && !isEqual(oldStyles[key] || {}, newStyles[key])) {
									acc[key] = newStyles[key];
								}
							} else if (oldStyles[key] !== newStyles[key]) {
								acc[key] = newStyles[key];
							}

							if (acc[key] === null) {
								acc[key] = NaN;
							}

							return acc;
						};
					};
			}

			return undefined;
		});

		var _contextReducer = reducers ? function (context, action, target) {
			contextReducer(context, action, target);
			reducers(context, action, target);
		} : contextReducer;

		// creates an initial styling for the context
		// styleContext(styling, _contextReducer);

		return function setStyle(styling) {
			try {
				// const styling = styler(newStyles);
				// injects a new styling to the context
				styleContext(styling, _contextReducer);
			} catch (e) {
				throw e;
			}
		};
	}

	function contextReducer(context, action, target) {
		var state = context.getState();
		var newState = Object.assign({}, state);
		// console.log("page context : "+JSON.stringify(action));

		switch (action.type) {
			case "updateUserStyle":
				context.find(target, { updateUserStyle: function updateUserStyle() {
						throw new TypeError("Target " + target + " component cannot be found.");
					} }).updateUserStyle(action.userStyle);

				return newState;
			case "changeUserStyle":
				context.find(target, { setUserStyle: function setUserStyle() {
						throw new TypeError("Target " + target + " component cannot be found.");
					} }).setUserStyle(action.userStyle);

				return newState;
			case "updatePageSafeArea":
				context.find(target, { setSafeArea: function setSafeArea() {
						throw new TypeError("Target " + target + " component cannot be found.");
					} }).setSafeArea(Object.assign({}, action.safeArea));

				return newState;
			case "invalidate":
				context.map(function (actor) {
					actor.setDirty(true);
				});

				return newState;
			case 'addChild':
				var rootName = target + "_" + action.name;
				var ctree = (0, _fromSFComponent.createActorTreeFromSFComponent)(action.component, rootName);

				if (action.classNames && typeof action.classNames !== 'string' && !Array.isArray(action.classNames)) {
					throw new Error(action.classNames + " classNames must be String or Array");
				}

				ctree[target + "_" + action.name] && action.classNames && Array.isArray(action.classNames) ? ctree[rootName].pushClassNames(action.classNames) : ctree[rootName].pushClassNames(action.classNames.split(" "));

				action.userStyle && ctree[rootName].setUserStyle(action.userStyle);
				context.addTree(ctree);

				return newState;
				break;
			case 'removeChild':
				context.remove(target);
				return newState;
				break;
			case 'removeChildren':
				context.removeChildren(target);

				return newState;
				break;
			case 'pushClassNames':
				context.find(target).pushClassNames(action.classNames);

				return newState;
				break;
			case 'removeClassName':
				context.find(target).removeClassName(action.className);

				return newState;
				break;
			case "orientationStarted":
				context.map(function (actor) {
					actor.setDirty(true);
				});

				orientationState = "started";
				return newState;
			case "orientationEnded":
				context.map(function (actor) {
					actor.setDirty(true);
				});

				orientationState = "ended";
				return newState;
		}

		return state;
	}

	exports.default = createPageContext;
	module.exports = exports["default"];
});